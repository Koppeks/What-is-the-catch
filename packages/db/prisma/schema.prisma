generator prismaClient {
    provider = "prisma-client-js"
}

generator zod {
    provider                  = "zod-prisma-types"
    output                    = "prismaZodSchemas"
    writeBarrelFiles          = "true"
    useMultipleFiles          = "true"
    createInputTypes          = "true"
    createPartialTypes        = "true"
    useTypeAssertions         = "true"
    createRelationValuesTypes = "true"
    writeNullishInModelTypes  = "true"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    id                 String         @id @default(cuid())
    email              String         @unique
    username           String         @db.VarChar(64)
    password           String
    userRole           AvailableRoles @default(USER)
    subscriptionStatus AccountStatus  @default(FREE)
    updatedAt          DateTime       @updatedAt
    createdAt          DateTime       @default(now())
}

model Document {
    id            String            @id @default(cuid())
    name          String
    locale        String? // "es-AR", "en-US"
    kind          DocumentKind?
    type          TypeRequest
    status        AnalysisStatus    @default(PENDING)
    clauses       Clause[]
    runs          AnalysisRun[]
    documentRules DocumentTrigger[]
    sourceUrl     String?
    updatedAt     DateTime          @updatedAt
    createdAt     DateTime          @default(now())
}

model DocumentTrigger {
    id            String  @id @default(cuid())
    documentId    String
    triggerId     String
    enabled       Boolean @default(true)
    minConfidence Float? // e.g. 0.6
    notes         String?

    document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
    trigger  Trigger  @relation(fields: [triggerId], references: [id], onDelete: Cascade)

    @@unique([documentId, triggerId])
    @@index([triggerId])
}

// Representation of a segment of the document
model Clause {
    id String @id @default(cuid())

    // Grouping
    documentId String
    document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

    // Tree, with self reference
    parentId String?
    parent   Clause?  @relation("ClauseToChildren", fields: [parentId], references: [id], onDelete: Cascade)
    children Clause[] @relation("ClauseToChildren")

    // Payload
    ordinalPath String // "22.1", "a", "b-4", "5-d"
    title       String
    text        String @db.Text
    order       Int
    depth       Int // numerical root order 0=parent, 1=children, 2=grandChildren, n...

    meta        Json? @db.Json// Whatever

    createdAt      DateTime         @default(now())
    updatedAt      DateTime         @updatedAt

    @@index([documentId, depth, order])
    @@index([documentId, ordinalPath])
}

model AnalysisRun {
    id String @id @default(cuid())

    documentId String
    document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

    status        AnalysisStatus @default(RUNNING)
    engineVersion String
    startedAt     DateTime       @default(now())
    finishedAt    DateTime
    overallRisk   Int @db.SmallInt @default(0)  // 0..100 summary for the doc
    notes         String

}

model Trigger {
    id          String  @id @default(cuid())
    key         String  @unique
    label       String
    description String?

    // Move patterns into a separate table (recommended):
    // patterns String[]  // ← remove if you adopt TriggerPattern
    patterns String[] // ← keep temporarily if you want; you can deprecate later

    source       TriggerSource @default(SYSTEM)
    state        TriggerState  @default(ACTIVE)
    mergedIntoId String?
    mergedInto   Trigger?      @relation("TriggerMerge", fields: [mergedIntoId], references: [id])
    mergeFrom    Trigger[]     @relation("TriggerMerge")
    reviewNotes  String?
    promotedAt   DateTime?

    // Rename ClauseType → ClauseCategory (see model below)
    clauseCategoryId String
    clauseCategory   ClauseCategory @relation(fields: [clauseCategoryId], references: [id], onDelete: Restrict)

    defaultSeverity Severity?

    // explicit per-document settings
    documentRules DocumentTrigger[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([key, state], map: "uniq_active_key_when_active")
    @@index([state, source])
    @@index([mergedIntoId])
}

model ClauseCategory {
    id                 String    @id @default(cuid())
    slug               String    @unique // e.g MODIFICATION_RIGHTS
    version            String    @default("0.0.1")
    defaultScoring     Float     @default(0.5)
    label              String // Modification rights
    isActive           Boolean   @default(true)
    Trigger            Trigger[]
    triggerInstruction String
    triggerKeywords    String[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Company {
    id           String         @id @default(cuid())
    slug         String         @unique
    displayName  String
    websiteUrl   String?
    countryCode  String?
    description  String?
    Service      Service[]
    CompanyAlias CompanyAlias[]
    Domain       Domain[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Service {
    id        String  @id @default(cuid())
    companyId String
    company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

    slug String
    name String
    note String?

    createdAt     DateTime        @default(now())
    updatedAt     DateTime        @updatedAt
    ServiceDomain ServiceDomain[]

    @@unique([companyId, slug])
    @@index([companyId, name])
}

model CompanyAlias {
    id        String  @id @default(cuid())
    companyId String
    company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

    kind      AliasKind
    value     String // e.g. "Google", "Alphabet Inc.", "YouTube"
    valueNorm String // lowercase/trimmed for lookup

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([companyId, valueNorm])
    @@index([valueNorm])
}

model Domain {
    id        String  @id @default(cuid())
    companyId String
    company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

    host String  @unique // e.g. "google.com", "spotify.com"
    note String?

    createdAt     DateTime        @default(now())
    updatedAt     DateTime        @updatedAt
    ServiceDomain ServiceDomain[]

    @@index([companyId])
}

model ServiceDomain {
    id        String  @id @default(cuid())
    serviceId String
    domainId  String
    service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
    domain    Domain  @relation(fields: [domainId], references: [id], onDelete: Cascade)

    // optional: narrow to legal paths (helps when one company has many services)
    pathPattern String? // e.g. "^/legal/terms|^/drive/terms"

    @@unique([serviceId, domainId, pathPattern])
    @@index([domainId])
    @@index([serviceId])
}

// --- enums --- 
enum AccountStatus {
    FREE
    PRO
}

enum TypeRequest {
    PASTE_TEXT
    UPLOAD
    URL_SCRAPE
    API
    EMBEDED // From extension
}

enum AnalysisStatus {
    PENDING
    RUNNING
    QUEUED
    DONE
    FAILED
}

enum Severity {
    NONE
    LOW
    MEDIUM
    HIGH
}

enum TriggerSource {
    SYSTEM
    AI
}

enum TriggerState {
    PROPOSED
    ACTIVE
    MERGED
    DEPRECATED
}

enum AvailableRoles {
    USER
    ADMIN
}

enum AliasKind {
    BRAND
    ALIAS
    LEGAL_ENTITY
}

enum DocumentKind { 
    TOS 
    PRIVACY 
    COOKIE 
    EULA 
    OTHER 
}
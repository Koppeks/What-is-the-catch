generator prismaClient {
    provider = "prisma-client-js"
}

generator zod {
    provider                  = "zod-prisma-types"
    output                    = "prismaZodSchemas"
    writeBarrelFiles          = "false"
    useMultipleFiles          = "true"
    createInputTypes          = "false"
    createPartialTypes        = "true"
    useTypeAssertions         = "true"
    createRelationValuesTypes = "true"
    writeNullishInModelTypes  = "true"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model user {
    id                 String         @id @default(cuid())
    email              String         @unique
    username           String         @db.VarChar(64)
    password           String
    userRole           AvailableRoles @default(USER)
    subscriptionStatus AccountStatus  @default(FREE)
    updatedAt          DateTime       @updatedAt
    createdAt          DateTime       @default(now())
}

model AnalysisRequest {
    id        String         @id @default(cuid())
    type      TypeRequest
    status    AnalysisStatus @default(PENDING)
    clauses   Clause[]
    triggers  Trigger[]
    sourceUrl String?
    language  String?
    updatedAt DateTime       @updatedAt
    createdAt DateTime       @default(now())
}

// Representation of a segment of the document
model Clause {
    id                String          @id @default(cuid())
    analysisRequest   AnalysisRequest @relation(fields: [analysisRequestId], references: [id])
    analysisRequestId String
    order             Int
    title             String
    content           String
    triggerWarning    String[]
    severity          Severity
    riskScore         Int // 0-100
    categories        String[] // e.g ["DataSharing", "Arbitration"]hits 
    hits              TriggerHit[]
    createdAt         DateTime        @default(now())
}

model Trigger {
    id          String   @id @default(cuid())
    key         String   @unique // e.g., "unilateral_changes_without_notice"
    label       String
    description String?
    patterns    String[]

    source          TriggerSource @default(SYSTEM)
    state           TriggerState  @default(ACTIVE)
    mergedIntoId    String?
    mergedInto      Trigger?      @relation("TriggerMerge", fields: [mergedIntoId], references: [id])
    mergeFrom       Trigger[]     @relation("TriggerMerge")
    reviewNotes     String?
    promotedAt      DateTime?
    category        String?
    defaultSeverity Severity?

    hits            TriggerHit[]
    AnalysisRequest AnalysisRequest[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([key, state], map: "uniq_active_key_when_active")
    @@index([state, source])
    @@index([mergedIntoId])
}

model TriggerHit {
    id String @id @default(cuid())

    clauseId String
    clause   Clause @relation(fields: [clauseId], references: [id], onDelete: Cascade)

    triggerId String
    trigger   Trigger @relation(fields: [triggerId], references: [id], onDelete: Cascade)

    confidence Float? // model confidence for this hit
    //confidence formula
    //baseValue = 0.0(no match), 0.5(contain some words), 1.0 (exact regex)
    //aiConfidence = from 0 to 100, turn in to 0.00 to 1.00
    //confidence = (0.3 * baseValue) + (0.7 * aiConfidence)
    matches    Json?

    @@unique([clauseId, triggerId])
}

model Company {
    id           String         @id @default(cuid())
    slug         String         @unique
    displayName  String
    websiteUrl   String?
    countryCode  String?
    description  String?
    Service      Service[]
    CompanyAlias CompanyAlias[]
    Domain Domain[]

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model Service {
    id        String  @id @default(cuid())
    companyId String
    company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

    slug String
    name String
    note String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([companyId, slug])
    @@index([companyId, name])
    ServiceDomain ServiceDomain[]
}

model CompanyAlias {
    id        String  @id @default(cuid())
    companyId String
    company   Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

    kind      AliasKind
    value     String // e.g. "Google", "Alphabet Inc.", "YouTube"
    valueNorm String // lowercase/trimmed for lookup

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@unique([companyId, valueNorm])
    @@index([valueNorm])
}

model Domain {
  id         String   @id @default(cuid())
  companyId  String
  company    Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  host       String   @unique    // e.g. "google.com", "spotify.com"
  note       String?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([companyId])
  ServiceDomain ServiceDomain[]
}

model ServiceDomain {
  id          String  @id @default(cuid())
  serviceId   String
  domainId    String
  service     Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  domain      Domain  @relation(fields: [domainId], references: [id], onDelete: Cascade)

  // optional: narrow to legal paths (helps when one company has many services)
  pathPattern String?  // e.g. "^/legal/terms|^/drive/terms"

  @@unique([serviceId, domainId, pathPattern])
  @@index([domainId])
  @@index([serviceId])
}

// --- enums --- 
enum AccountStatus {
    FREE
    PRO
}

enum TypeRequest {
    PASTE_TEXT
    UPLOAD
    URL_SCRAPE
    API
    EMBEDED // From extension
}

enum AnalysisStatus {
    PENDING
    RUNNING
    QUEUED
    DONE
    FAILED
}

enum Severity {
    NONE
    LOW
    MEDIUM
    HIGH
}

enum TriggerSource {
    SYSTEM
    AI
}

enum TriggerState {
    PROPOSED
    ACTIVE
    MERGED
    DEPRECATED
}

enum AvailableRoles {
    USER
    ADMIN
}

enum AliasKind {
    BRAND
    ALIAS
    LEGAL_ENTITY
}
